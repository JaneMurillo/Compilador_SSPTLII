# Compilador_SSPTLII

En este repositorio se encuentran las carpetas donde se encuentra el c√≥digo de las actividades realizadas para el desarrollo del Proyecto para la materia Seminario de Soluci√≥n de Problemas de Traductores de Lenguaje II.

Las actividades para el desarrollo del Compilador se encuentran divididas en las siguientes carpetas:

* Actividad 1: **MiniAnalizadorLexico** - Mini Analizador L√©xico
* Actividad 2: **Compilador_SSPTLII** - Analizador L√©xico
* Actividad 3: **MiniAnalizadorSintactico** - Mini Analizador sint√°ctico
* Actividad 4: **AnalizadorSintacticoObjetos** - Analizador Sint√°ctico implementaci√≥n usando Objetos
* Actividad 5: **AnalizadorSintacticoGramatica** - Gram√°tica del compilador



## Mini Analizador L√©xico

El contenido de esta primera etapa tiene la implementaci√≥n del c√≥digo para el comienzo del desarrollo de un compilador: el An√°lisis L√©xico, con el cu√°l, ser√° posible  leer secuencias de caracteres de entrada, para de esta manera analizar y buscar los componentes l√©xicos que recibe, comprobando si los tokens que obtiene son legales para el an√°lisis de identificadores, n√∫meros enteros, n√∫meros reales, junto con operadores de adici√≥n y de multiplicacion.

En la imagen se muestra una prueba de los tokens que identifica el mini analizador l√©xico:

<img src="./MiniAnalizadorLexico_SSPTLII/images/funcionamiento-mini-analizador-lexico.png">

La entrada de la cadena obtenida en 'main.cpp', de manera que cuando se obtiene un token, se analiza en los distintos casos posibles:
- Determinar si es una letra
- Determinar si es un digito
- Determinar si es un car√°cter de adici√≥n
- Determinar si es un car√°cter de multiplicaci√≥n

Dentro de la carpeta *MiniAnalizadorLexico_SSPTLII*, en el README.ms se puede leer m√°s informaci√≥n acerca de ello.


## Analizador L√©xico

El programa comienza solicitando una cadena al usuario, de manera que cuando este la introduce, el c√≥digo va validando mediante estructuras simples si dirigirse a un estado de aceptaci√≥n o al siguiente estado, para evaluar si es de aceptaci√≥n. De esta manera, se va avanzando en la cadena, evaluando cada token para identificarlo, y regresandose una posici√≥n cuando es necesario para evaluar el siguiente token. Cuando termina de evaluarse todos los tokens, se imprime el final del analizador l√©xico, determinado por el car√°cter '$'.
En esta etapa se agregaron m√°s opciones para los tokens, de acuerdo a la tabla presentada para la actividad. Se agreg√≥ tambi√©n la funci√≥n de aceptacion2, porque anteriormente, se imprimian la identificaci√≥n de algunos tokens que capturaban un car√°cter de m√°s. 

En la imagen se muestra una prueba de distintos tokens en el analizador l√©xico y c√≥mo identifica el tipo de cada uno:

<img src="./Compilador_SSPTLII/images/funcionamiento-del-analizador-lexico.png">

Los casos posibles seg√∫n la tabla proporcionada, se pueden clasificar como:
- Letra
- Digito
- Operador de adici√≥n
- Operador de multiplicaci√≥n
- Operador relacional
- Operador l√≥gico
- Operador de igualdad
- Parentesis, corchete
- Coma, punto y coma

Dentro de la carpeta *Compilador_SSPTLII*, en el README.ms se puede leer m√°s informaci√≥n acerca de ello.


## Mini Analizador Sint√°ctico

El programa se desarrolla mediante el uso de una Pila de enteros, que va validando la cadena ingresada en el programa, observando lo que se encuentra en la entrada y salida con la tabla de reducciones. Observandolo m√°s detalladamente, se puede decir que a partir de '$0' que se introducen al principio de la pila, se va a introducir el nuevo token que se encuentre en entrada, para identificarlo, comparar la pila con el resultado de la identificaci√≥n del analizador l√©xico, y luego determinar la acci√≥n a realizar, mostrando lo que se encuentra actualmente en la pila hasta que ocurra una reducci√≥n de la regla 1, o para el ejercicio dos, que ocurran las reducciones de la regla 2 y de la 1 para su aceptacion.

En la imagen se muestran los distintos tokens analizados, en la entrada, salida y la pila:

<img src="./MiniAnalizadorSintactico_SSPTLII/images/Funcionamiento_del_mini_analizador_sintactico.png">
<img src="./MiniAnalizadorSintactico_SSPTLII/images/Funcionamiento_del_mini_analizador_sintactico_e2_1.png">
<img src="./MiniAnalizadorSintactico_SSPTLII/images/Funcionamiento_del_mini_analizador_sintactico_e2_2.png">

Dentro de la carpeta *MiniAnalizadorSintactico_SSPTLII*, en el README.ms se puede leer m√°s informaci√≥n acerca de ello.

## Mini Analizador Sint√°ctico con Objetos

El contenido de esta etapa tiene la implementaci√≥n del c√≥digo para el uso de una pila de objetos, de manera que es posible leer cadenas como objetos de entrada, para de esta manera analizar y buscar los componentes sint√°cticos en la tabla LR para llegar a la aceptaci√≥n de los ejercicios 1 y 2 que recibe, comprobando si los tokens que se obtienen son legales.

En las imagenes se muestra c√≥mo se realiza el an√°lisis mediante el Algoritmo de apilar con Objetos:

<img src="./AnalizadorSintacticoObjetos_SSPTLII/images/Funcionamiento_del_mini_analizador_sintactico.png">
<img src="./AnalizadorSintacticoObjetos_SSPTLII/images/Funcionamiento_del_mini_analizador_sintactico_e2_1.png">
<img src="./AnalizadorSintacticoObjetos_SSPTLII/images/Funcionamiento_del_mini_analizador_sintactico_e2_2.png">

Se implement√≥ la clase padre ElementoPila, donde de ella surgen sus clases hijos 'Terminal', 'NoTerminal' y 'Estado' para que la clase Pila que tenia originalmente, reciba los objetos que regresan estas clases, los cuales se analizan al introducir uno a uno en la Pila de objetos ya sea con su clasificaci√≥n de Terminal, Estado o No Terminal.
Dentro de la carpeta *AnalizadorSintacticoObjetos_SSPTLII*, en el README.md se puede leer m√°s informaci√≥n acerca de ello.

### An√°lizador Sint√°ctico Gram√°tica

El Analizador Sint√°ctico desarrollado en esta etapa comprueba la correcta construcci√≥n de las cadenas introducidas, de manera que en base al 'Archivo.lr', se utiliz√≥ la matriz de las reglas de la gram√°tica, donde los atributos de dichas reglas son utilizados mediante nodos. Los atributos corresponden a el id de la regla, nombre de la regla y cantidad de tokens de la regla, informaci√≥n la cu√°l se va a guardar en para su impresi√≥n final en el √Årbol Sint√°ctico. Cada regla tiene su propia clase con sus atributos con su m√©todo 'muestra()'.

<img src="./nalizadorSintactico_SSPTLII/images/Analizador_sintactico.png">
<img src="./nalizadorSintactico_SSPTLII/images/Analizador_sintactico2.png">

Las imagenes anteriores corresponden a el recorrido del √Årbol Sint√°ctico.
Dentro de la carpeta *AnalizadorSintactico_SSPTLII*, en el README.md se puede observar el c√≥digo utilizado para la implementaci√≥n del programa.


# Proyecto IoT NODEMCU8266 Sensor
# ![Proyecto IOT NodeMCU8266](https://user-images.githubusercontent.com/40220378/170843779-1dfd5265-59ee-4319-850b-68073664d2c9.png)


En este apartado se muestra c√≥mo se desarrolla el despliegue de la implementaci√≥n del Proyecto del Internet de las cosas con un Sensor, el cu√°l conecta una placa NODEMCU8266 con un broker, utilizando las tecnolog√≠as de Docker, K8s, K3S, K3D y Rancher.
En la carpeta *IoT-NODEMCU8266-Sensor* se encuentran los archivos utilizados para el desarrollo, donde en el archivo 'Proyecto-IoT' se puede observar m√°s informaci√≥n acerca del mismo.

## Autores
- **Victor Manuel Velasco Hern√°ndez**
- **Jeanette Murillo Cortes**

## Arquitectura del Proyecto üìê

En la siguiente imagen se muestra la arquitectura propuesta para que el sistema muestre el uso de los sensores y el led mediante el broker EMQX.

<img src="./IoT-NODEMCU8266-Sensor/Arquitectura.png">

## Despliegue del Proyecto ‚öô
El despliegue del proyecto se divide en dos:
*Placa NodeMCU8266
*Broker EMQX

### Instalaciones para el despliegue üß©

Para el despliegue del proyecto se debe de tener como herramientas:
* Una placa NODEMUC8266
* Cable usb con puerto Micro-B
* 2 leds
* 2 fotoresistencias
* 1 resistencia
* Para observar mejor el funcionamiento del m√≥dulo de internet, se recomienda una PowerBank

Y previamente instalado:
* Arduino IDE
* Docker
Adem√°s de algunas otras las cuales se mencionan sus comandos de instalaci√≥n en el documento 'Proyecto-IoT' como:
* Chocolatey
* K3S, K3D, Rancher

### Desarrollo del Despliegue

#### Placa NodeMCU8266 üë®üèª‚Äçüíª
Una vez que instaladas y obtenidas las anteriores herramientas, primeramente se tiene que abrir el IDE de Arduino para cargar el archivo 'NODEMCU2'. En este caso, ArduinoIDLE solicitar√° hacer la creaci√≥n de una carpeta, a lo cu√°l le daremos permiso. Una vez con el c√≥digo dentro de Arduino, se debe de instalar la libreria que permite el uso de la placa NODEMCU8266, para lo cu√°l, se sugieren los siguientes pasos:

**1.** Primeramente ir al repositorio oficial del ESP8266: https://github.com/esp8266/arduino 

**2.** Ahi se encuentra el link oficial que le dice a Arduino qu√© descargar para el uso de NODEMCU8366:
https://arduino.esp8266.com/stable/package_esp8266com_index.json

**3.** En el IDE de Arduino, abrir **'Archivo>Preferencias'** y pegar el link en 'Gestor de URLs Adicionales de Tarjetas: '

**4.** Dar click en Ok

Ya con la libreria descargada, conectamos la NODEMCU8266 a uno de los puertos de nuestra m√°quina, conectando nuestra placa con el IDE de la siguiente forma:

**5.** Ir a **'Herramientas>Placa:Arduino/Genuino Uno>Gestor de tarjetas'**

**6.** En el campo de busqueda poner 'esp8266' y al encontrarlo, instalar dicha librer√≠a

**7.** Cerrar el Gestor de tarjetas y abrirlo nuevamente

**8.** Podemos observar ahora la placa NODEMCU8266, de manera que ahora se debe de dar click en 'Generic ESP8266 Module' (Es la 01) para seleccionarla
Pd. Tambi√©n existe la ESP8285 (Es la 12)

**9.** En herramientas checar los siguientes atributos:

   **Flash Size:** Se debe de observar si es 01 o 12, como se mencion√≥ anteriormente
   
   **Upload Speed:** Es el nivel de carga del programa, esto depende del valor y carga del puerto y del usb
    
**10.** En caso de buscar m√°s informaci√≥n para este proceso, orientarse mediante el siguiente url de Youtube, link video: https://www.youtube.com/watch?v=0g7sazWXfEI

De esta manera, una vez seleccionada la placa, procedemos a, dentro del c√≥digo, poner nuestra red de internet a la cu√°l nos conectaremos, junto con su contrase√±a. As√≠, ya podemos compilar el programa para cargarlo a la placa, de esta forma, comenzar√° a buscar la se√±al del internet previamente configurado, y en la pantalla de salida del IDE, esperaremos hasta observar el mensaje de que 'Se ha conectado al internet'. 
El siguiente paso es opcional, el cu√°l consiste en decidir si dejar la placa conectada a la computadora o conectar la placa a un PowerBank (cuando se conecta a este √∫ltimo, se demuestra que la placa puede seguir utilizando el programa a√∫n cuando ya no esta conectado a nuestro equipo, utilizando su modulo ESP8266 que contiene el dispositivo WiFi.

Las conexiones que fueron utilizadas de acuerdo a al diagrama de la arquitectura se muestran en la siguiente imagen:


Adem√°s, en el siguiente link se explica a mayor detalle c√≥mo se realiz√≥ este apartado del proyecto adem√°s de la demostraci√≥n del funcionamiento del mismo: https://drive.google.com/file/d/1ddA4rBIDVZXG3Wm8QdmoKxumuqb20x7B/view?usp=sharing

<img src="./IoT-NODEMCU8266-Sensor/EMQX-Broker.png">

#### Broker EMQX üì¶
Para poder implementar el Broker, es necesario instalar K3D y K3S, para poder comenzar con el cluster, para lo cu√°l se usaron los siguientes comandos(esta implementaci√≥n fue en Windows por medio de PowerShell), recuerda que se debe tener instalado Chocolatey: 
```
CHOCO INSTALL K3D -Y
CHOCO INSTALL JQ -Y
CHOCO INSTALL YQ -Y
CHOCO INSTALL KUBERNETES-HELM -Y
```

Una vez instalado K3D, se usaran el siguiente comando para crear el cl√∫ster con Rancher, en el cu√°l se expondran los puertos que el despliegue requiera: 
```
K3D CLUSTER CREATE --API-PORT 6448 -P
"18083:18083" -P "1883:1883" -P "8883:8883" -P
"8081:8081" -P "8083:8083" -P "8084:8084" IOT
```

Para configurar, la variable de entorno del cl√∫ster, se introducir√° el siguiente comando(exclusivo de PowerShell):
```
K3D KUBECONFIG GET IoT > $ENV:KUBECONFIG_FILE
$ENV:KUBECONFIG=($ENV:KUBECONFIG_FILE)
```
Despu√©s, al archivo YAML que se encuentra en este repositorio, lo aplicamos al cl√∫ster de K3S con el comando, para generar el Deployment y el Service:
```
K3S KUBECTL APPLY -F EMQX.YAML
```

Es importante recordar que los puertos **18083, 1883, 8883, 8081, 8083, 8084** ser√°n utilizados.
Tras esto, procederemos a generar los NodePorts del proyecto, aplicando el siguiente comando a todos los puertos:
```
KUBECTL EXPOSE DEPLOYMENT EMQX-DEPLOYMENT --NAME EMQX-DASHBOARD --PORT=<port> --TARGET-PORT=<same port> --TYPE NODEPORT
```

Y con esto, le aplicamos el Port-forward para vincular a nuestra PC los puertos a utilizar, con el comando:
```
KUBECTL PORT-FORWARD EMQX-DASHBOARD <port>:<same port>

```
## Uso del Broker EMQX
Accedemos a nuestro Broker por medio del localhost del equipo en el que se encuentre instalado, en el socket **18083**, e iniciamos sesi√≥n con un usuario default:
  **Usuario:** admin
  
  **Password:** public

Suponiendo que las placas NodeMCU8266 est√°n ya conectadas y registradas como clientes dentro del broker, en la barra lateral izquierda del Dashboard, accedemos a **"Tools>Websocket"** 


Despu√©s, el siguiente paso es dirigirnos al Broker EMQX de la siguiente manera:

1. Entrar a la p√°gina emqx.com/en
2. Dirigirse al apartado gratis y publico, con este link:
https://www.emqx.com/en/mqtt/public-mqtt5-broker o buscar la opci√≥n 'Publick mqtt5 broker'
3. Ir y dar click al bot√≥n de 'Learn more...' en el apartado de Online MQTT Client
4. Dar click en el bot√≥n de 'Visit MQTT WebSocket Toolkit'
5. Click en New conection
6. Crear un client

7. En el apartado de 'Tools' dar click en 'Websocket' y hacer las siguientes configuraciones:
   1. Name: ESP8266
   2. Client ID: esp8266-client
   3. Username: admin
   4. Password: public
8. Dar click en el bot√≥n 'Connect' y observar que la placa marque como Connected

9. Por √∫ltimo, en 'Messsages', configurar:
   1. Topic: esp8266/test
   2. Messages: 1 (para encender) o 0 (para apagar)
   3. Dar click en bot√≥n para enviar y vemos si se envi√≥ el mensaje

De esta manera, si el mensaje ha sido enviado correctamente, el led de la placa NODEMCU8266 prender√° o se apagar√°, seg√∫n reciba el mensaje.

En el broker, se mostrar√° la informaci√≥n que se obtiene de los resultados del sensor:

<img src="./IoT-NODEMCU8266-Sensor/Conexiones.png">
